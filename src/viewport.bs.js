// Generated by BUCKLESCRIPT VERSION 6.0.1, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var React = require("react");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Dom_html$ReactHooksTemplate = require("./dom_html.bs.js");

function Viewport(Props) {
  var onMouseDown = Props.onMouseDown;
  var onMouseMove = Props.onMouseMove;
  var onMouseUp = Props.onMouseUp;
  var nodes = Props.nodes;
  var edges = Props.edges;
  var radius = Props.radius;
  var width = Props.width;
  var height = Props.height;
  var hNodes = Props.hNodes;
  var grid = Props.grid;
  var keyHandler = Props.keyHandler;
  var canvas_ref = React.useRef(null);
  var draw_grid = function (ctx) {
    if (grid !== undefined) {
      var grid$1 = grid;
      Dom_html$ReactHooksTemplate.setStrokeStyle(ctx, "#6495ED");
      ctx.beginPath();
      var dx = Caml_int32.div(width, grid$1);
      var dy = Caml_int32.div(height, grid$1);
      var draw_line_vert = function (_n) {
        while(true) {
          var n = _n;
          if (n === 0) {
            return /* () */0;
          } else {
            var x = Caml_int32.imul(n, dx);
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            _n = n - 1 | 0;
            continue ;
          }
        };
      };
      var draw_line_horiz = function (_n) {
        while(true) {
          var n = _n;
          if (n === 0) {
            return /* () */0;
          } else {
            var y = Caml_int32.imul(n, dy);
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            _n = n - 1 | 0;
            continue ;
          }
        };
      };
      draw_line_vert(grid$1 - 1 | 0);
      draw_line_horiz(grid$1 - 1 | 0);
      ctx.stroke();
      return /* () */0;
    } else {
      return /* () */0;
    }
  };
  var draw = function (ctx) {
    var draw_node = function (param) {
      var match = param[1];
      var y = match[1];
      var x = match[0];
      ctx.moveTo(x, y);
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      return /* () */0;
    };
    ctx.clearRect(0, 0, width, height);
    draw_grid(ctx);
    ctx.beginPath();
    Dom_html$ReactHooksTemplate.setStrokeStyle(ctx, "#000000");
    List.iter((function (param) {
            var nodes$1 = nodes;
            var param$1 = param;
            var match = List.assoc(param$1[0], nodes$1);
            var match$1 = List.assoc(param$1[1], nodes$1);
            ctx.moveTo(match[0], match[1]);
            ctx.lineTo(match$1[0], match$1[1]);
            ctx.stroke();
            return /* () */0;
          }), edges);
    ctx.beginPath();
    Dom_html$ReactHooksTemplate.setFillStyle(ctx, "#FF7F50");
    List.iter(draw_node, nodes);
    ctx.fill();
    ctx.beginPath();
    Dom_html$ReactHooksTemplate.setFillStyle(ctx, "#6495ED");
    List.iter(draw_node, hNodes);
    ctx.fill();
    return /* () */0;
  };
  React.useEffect((function () {
          var ctx = Dom_html$ReactHooksTemplate.domToCanvas(Caml_option.nullable_to_opt(canvas_ref.current)).getContext("2d");
          draw(ctx);
          return undefined;
        }));
  return React.createElement("canvas", {
              ref: canvas_ref,
              style: {
                border: "1px solid #000000",
                outline: "none"
              },
              tabIndex: 0,
              height: String(height),
              width: String(width),
              onKeyDown: keyHandler,
              onMouseDown: onMouseDown,
              onMouseMove: onMouseMove,
              onMouseUp: onMouseUp
            });
}

var make = Viewport;

exports.make = make;
/* react Not a pure module */
